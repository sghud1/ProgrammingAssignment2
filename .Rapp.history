makeCacheMatrix <- function(x = matrix()) {#
	inverse <- NULL#
	set <- function(y) {#
			x <<- y#
			inverse <<- NULL#
	}#
	get <- function() x#
	setinverse <- function(inverse) inv <<- inverse#
	getinverse <- function() inv#
	list(set = set, get = get,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pullin from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x'#
        inverse <- x$getinverse()#
        if(!is.null(inv)) {#
        		message("getting cached data")#
        		return(inv)#
        }#
        data <- x$get()#
        inv <- solve(mat.data, ...)#
        x$setinverse(inv)#
        return(inv)#
}#
#
mat <-matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
makeCacheMatrix <- function(x = matrix()) {#
	inv <- NULL#
	set <- function(y) {#
			x <<- y#
			inv <<- NULL#
	}#
	get <- function() x#
	setinverse <- function(inv) inv <<- inverse#
	getinverse <- function() inv#
	list(set = set, get = get,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x'#
        inv <- x$getinverse()#
        if(!is.null(inv)) {#
        		message("getting cached data")#
        		return(inv)#
        }#
        data <- x$get()#
        inv <- solve(mat.data, ...)#
        x$setinverse(inv)#
        return(inv)#
}#
#
mat <-matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
## These functions will calculate the inverse of a matrix and cache it so#
## that it does not have to be computed each time, and call the inverse matrix#
## by pulling from the cache, or computing the inverse if it is a new matrix#
#
## This function calculates the inverse matrix and caches it#
#
makeCacheMatrix <- function(x = matrix()) {#
	inv <- NULL#
	set <- function(y) {#
			x <<- y#
			inv <<- NULL#
	}#
	get <- function() x#
	setinverse <- function(inv) inv <<- inverse#
	getinverse <- function() inv#
	list(set = set, get = get,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x'#
        inv <- x$getinverse()#
        if(!is.null(inv)) {#
        		message("getting cached data")#
        		return(inv)#
        }#
        data <- x$get()#
        inv <- solve(mat.data, ...)#
        x$setinverse(inv)#
        return(inv)#
}#
#
mat <-matrix(mat.data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
## These functions will calculate the inverse of a matrix and cache it so#
## that it does not have to be computed each time, and call the inverse matrix#
## by pulling from the cache, or computing the inverse if it is a new matrix#
#
## This function calculates the inverse matrix and caches it#
#
makeCacheMatrix <- function(x = matrix()) {#
	inv <- NULL#
	set <- function(y) {#
			x <<- y#
			inv <<- NULL#
	}#
	get <- function() x#
	setinverse <- function(inv) inv <<- inverse#
	getinverse <- function() inv#
	list(set = set, get = get,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x'#
        inv <- x$getinverse()#
        if(!is.null(inv)) {#
        		message("getting cached data")#
        		return(inv)#
        }#
        data <- x$get()#
        inv <- solve(data, ...)#
        x$setinverse(inv)#
        return(inv)#
}#
#
mat <-matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
## These functions will calculate the inverse of a matrix and cache it so#
## that it does not have to be computed each time, and call the inverse matrix#
## by pulling from the cache, or computing the inverse if it is a new matrix#
#
## This function calculates the inverse matrix and caches it#
#
makeCacheMatrix <- function(x = matrix()) {#
	inv <- NULL#
	set <- function(y) {#
			x <<- y#
			inv <<- NULL#
	}#
	get <- function() x#
	setinverse <- function(inverse) inv <<- inverse#
	getinverse <- function() inv#
	list(set = set, get = get,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x'#
        inv = x$getinverse()#
        if(!is.null(inv)) {#
        		message("getting cached data")#
        		return(inv)#
        }#
        mat.data <- x$get()#
        inv <- solve(mat.data, ...)#
        x$setinverse(inv)#
        return(inv)#
}#
#
mat <-matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
## These functions will calculate the inverse of a matrix and cache it so#
## that it does not have to be computed each time, and call the inverse matrix#
## by pulling from the cache, or computing the inverse if it is a new matrix#
#
## This function calculates the inverse matrix and caches it#
#
makeCacheMatrix <- function(x = matrix()) {#
	inverse <- NULL#
	set <- function(y) {#
			x <<- y#
			inverse <<- NULL#
	}#
	get <- function() x#
	setinverse <- function(inverse) inv <<- inverse#
	getinverse <- function() inv#
	list(set = set, get = get,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x'#
        inverse = x$getinverse()#
        if(!is.null(inverse)) {#
        		message("getting cached data")#
        		return(inverse)#
        }#
        mat.data <- x$get()#
        inverse <- solve(mat.data, ...)#
        x$setinverse(inverse)#
        return(inverse)#
}#
#
mat <-matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
## These functions will calculate the inverse of a matrix and cache it so#
## that it does not have to be computed each time, and call the inverse matrix#
## by pulling from the cache, or computing the inverse if it is a new matrix#
#
## This function calculates the inverse matrix and caches it#
#
makeCacheMatrix <- function(x = matrix()) {#
	inverse <- NULL#
	set <- function(y) {#
			x <<- y#
			inverse <<- NULL#
	}#
	get <- function() x#
	setinverse <- function(inverse) inv <<- inverse#
	getinverse <- function() inv#
	list(set = set, get = get,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x'#
        inverse = x$getinverse()#
        if(!is.null(inv)) {#
        		message("getting cached data")#
        		return(inv)#
        }#
        mat.data <- x$get()#
        inverse <- solve(mat.data, ...)#
        x$setinverse(inv)#
        return(inv)#
}
mat <-matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
## These functions will calculate the inverse of a matrix and cache it so#
## that it does not have to be computed each time, and call the inverse matrix#
## by pulling from the cache, or computing the inverse if it is a new matrix#
#
## This function calculates the inverse matrix and caches it#
#
makeCacheMatrix <- function(x = matrix()) {#
	inverse <- NULL#
	set <- function(y) {#
			x <<- y#
			inv <<- NULL#
	}#
	get <- function() x#
	setinverse <- function(inverse) inv <<- inverse#
	getinverse <- function() inv#
	list(set = set, get = get,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x'#
        inverse = x$getinverse()#
        if(!is.null(inv)) {#
        		message("getting cached data")#
        		return(inv)#
        }#
        mat.data <- x$get()#
        inverse <- solve(mat.data, ...)#
        x$setinverse(inv)#
        return(inv)#
}#
#
mat <-matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
## These functions will calculate the inverse of a matrix and cache it so#
## that it does not have to be computed each time, and call the inverse matrix#
## by pulling from the cache, or computing the inverse if it is a new matrix#
#
## This function calculates the inverse matrix and caches it#
#
makeCacheMatrix <- function(x = matrix()) {#
	inv <- NULL#
	set <- function(y) {#
			x <<- y#
			inv <<- NULL#
	}#
	get <- function() x#
	setinverse <- function(inverse) inv <<- inverse#
	getinverse <- function() inv#
	list(set = set, get = get,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x'#
        inverse = x$getinverse()#
        if(!is.null(inv)) {#
        		message("getting cached data")#
        		return(inv)#
        }#
        mat.data <- x$get()#
        inverse <- solve(mat.data, ...)#
        x$setinverse(inv)#
        return(inv)#
}#
#
mat <-matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
## These functions will calculate the inverse of a matrix and cache it so#
## that it does not have to be computed each time, and call the inverse matrix#
## by pulling from the cache, or computing the inverse if it is a new matrix#
#
## This function calculates the inverse matrix and caches it#
#
makeCacheMatrix <- function(x = matrix()) {#
	inv <- NULL#
	set <- function(y) {#
			x <<- y#
			inv <<- NULL#
	}#
	get <- function() x#
	setinverse <- function(inverse) inv <<- inverse#
	getinverse <- function() inv#
	list(set = set, get = get,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x'#
        inverse = x$getinverse()#
        if(!is.null(inverse)) {#
        		message("getting cached data")#
        		return(inverse)#
        }#
        mat.data <- x$get()#
        inverse <- solve(mat.data, ...)#
        x$setinverse(inverse)#
        return(inverse)#
}#
#
mat <-matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
mat
## These functions will calculate the inverse of a matrix and cache it so#
## that it does not have to be computed each time, and call the inverse matrix#
## by pulling from the cache, or computing the inverse if it is a new matrix#
#
## This function contains a list of four functions to: set the matrix, get the matrix, set the#
## inverse, and get the inverse. This is used as the input to the cacheSolve function below.#
#
makeCacheMatrix <- function(x = matrix()) {#
	inv <- NULL#
	setmatrix <- function(y) {#
			x <<- y			## cache the inputted matrix so cacheSolve can check for changes#
			inv <<- NULL #
	}#
	getmatrix <- function() x#
	setinverse <- function(inverse) inv <<- inverse		##cache the matrix inverse#
	getinverse <- function() inv#
	## creates a list of the four functions described above#
	list(setmatrix = setmatrix, getmatrix = getmatrix,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x' from the cache#
        inverse = x$getinverse()#
        if(!is.null(inverse)) {#
        		message("getting cached data")#
        		return(inverse)#
        }#
        ## If matrix inverse has not been solved, solve for inverse and return#
        mat.data <- x$get()#
        inverse <- solve(mat.data, ...)#
        x$setinverse(inverse)#
        return(inverse)#
}#
#
mat <- matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
## These functions will calculate the inverse of a matrix and cache it so#
## that it does not have to be computed each time, and call the inverse matrix#
## by pulling from the cache, or computing the inverse if it is a new matrix#
#
## This function contains a list of four functions to: set the matrix, get the matrix, set the#
## inverse, and get the inverse. This is used as the input to the cacheSolve function below.#
#
makeCacheMatrix <- function(x = matrix()) {#
	inv <- NULL#
	setmatrix <- function(y) {#
			x <<- y			## cache the inputted matrix so cacheSolve can check for changes#
			inv <<- NULL #
	}#
	getmatrix <- function() x#
	setinverse <- function(inverse) inv <<- inverse		##cache the matrix inverse#
	getinverse <- function() inv#
	## creates a list of the four functions described above#
	list(setmatrix = setmatrix, getmatrix = getmatrix,#
		 setinverse = setinverse,#
		 getinverse = getinverse)#
}#
## This function returns a matrix that is the inverse of 'x' by either pulling from#
## the cache or computing the inverse of a new matrix#
#
cacheSolve <- function(x, ...) {#
        ## Return a matrix that is the inverse of 'x' from the cache#
        inverse = x$getinverse()#
        if(!is.null(inverse)) {#
        		message("getting cached data")#
        		return(inverse)#
        }#
        ## If matrix inverse has not been solved, solve for inverse and return#
        mat.data <- x$getmatrix()#
        inverse <- solve(mat.data, ...)#
        x$setinverse(inverse)#
        return(inverse)#
}#
#
mat <- matrix(data = c(4,2,7,6), nrow = 2, ncol = 2)#
mat2 <- makeCacheMatrix(mat)#
cacheSolve(mat2)#
cacheSolve(mat2)
